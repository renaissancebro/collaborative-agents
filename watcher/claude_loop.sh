#!/bin/bash

# Claude Loop - Code Fix Application Agent
# This script continuously reads TODO items and applies fixes to the codebase

set -euo pipefail

# Configuration
CODEBASE_DIR="../codebase"
POSTBOX_DIR="../postbox"
TODO_FILE="$POSTBOX_DIR/todo.md"
COMPLETED_FILE="$POSTBOX_DIR/completed-todos.md"
LOG_FILE="$POSTBOX_DIR/claude.log"
SCAN_INTERVAL=60  # 1 minute in seconds
LOCK_FILE="/tmp/claude_loop.lock"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a "$LOG_FILE"
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1" | tee -a "$LOG_FILE"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" | tee -a "$LOG_FILE"
}

# Check if Claude CLI is available
check_claude_cli() {
    if ! command -v claude &> /dev/null; then
        error "Claude CLI not found. Please install Claude Code first."
        error "Install from: https://docs.anthropic.com/claude/docs/claude-code"
        exit 1
    fi
}

# Check if required directories exist
check_directories() {
    if [ ! -d "$CODEBASE_DIR" ]; then
        error "Codebase directory not found: $CODEBASE_DIR"
        exit 1
    fi
    
    mkdir -p "$POSTBOX_DIR"
    
    if [ ! -f "$COMPLETED_FILE" ]; then
        echo "# Completed TODO Items" > "$COMPLETED_FILE"
        echo "" >> "$COMPLETED_FILE"
        echo "Generated by Claude Agent on $(date)" >> "$COMPLETED_FILE"
        echo "" >> "$COMPLETED_FILE"
    fi
}

# Create lock file to prevent multiple instances
create_lock() {
    if [ -f "$LOCK_FILE" ]; then
        local pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            error "Another instance is already running (PID: $pid)"
            exit 1
        else
            warn "Removing stale lock file"
            rm -f "$LOCK_FILE"
        fi
    fi
    
    echo $$ > "$LOCK_FILE"
    trap cleanup EXIT
}

cleanup() {
    rm -f "$LOCK_FILE"
    info "Claude loop stopped"
}

# Parse TODO items from the todo.md file
parse_todo_items() {
    if [ ! -f "$TODO_FILE" ]; then
        return 0
    fi
    
    # Extract unchecked TODO items
    grep "^- \[ \]" "$TODO_FILE" | head -1
}

# Extract file path and line number from TODO item
extract_file_info() {
    local todo_item="$1"
    
    # Pattern: "- [ ] Fix [issue_type] in [filename] at line [line_number]: [description]"
    local file_pattern="in ([^[:space:]]+\.(py|js|ts|jsx|tsx)) at line ([0-9]+)"
    
    if [[ $todo_item =~ $file_pattern ]]; then
        local filename="${BASH_REMATCH[1]}"
        local line_number="${BASH_REMATCH[3]}"
        echo "$filename:$line_number"
    else
        echo ""
    fi
}

# Apply fix using Claude CLI
apply_fix() {
    local todo_item="$1"
    local file_info=$(extract_file_info "$todo_item")
    
    if [ -z "$file_info" ]; then
        warn "Could not extract file information from TODO item: $todo_item"
        return 1
    fi
    
    local filename=$(echo "$file_info" | cut -d: -f1)
    local line_number=$(echo "$file_info" | cut -d: -f2)
    local full_path="$CODEBASE_DIR/$filename"
    
    if [ ! -f "$full_path" ]; then
        warn "File not found: $full_path"
        return 1
    fi
    
    info "üîß Applying fix to $filename at line $line_number"
    
    # Initialize memory system if not already done
    ../helpers/memory_manager.sh init > /dev/null 2>&1 || true
    
    local fix_start_time=$(date +%s)
    
    # Create a detailed prompt for Claude
    local temp_prompt="/tmp/claude_fix_prompt.txt"
    cat > "$temp_prompt" << EOF
You are a senior software engineer tasked with fixing code issues. 

TODO Item: $todo_item

File: $filename
Current code context around line $line_number:

\`\`\`
$(sed -n "$((line_number-5)),$((line_number+5))p" "$full_path" | cat -n)
\`\`\`

Full file content:
\`\`\`
$(cat "$full_path")
\`\`\`

Please:
1. Analyze the specific issue mentioned in the TODO
2. Apply the minimal fix needed
3. Ensure the fix doesn't break existing functionality
4. Maintain the original code style and patterns

Return your response as a JSON object with:
{
  "success": true/false,
  "fix_applied": "description of what was fixed",
  "modified_content": "the complete fixed file content",
  "explanation": "brief explanation of the changes made"
}
EOF
    
    # Run Claude to get the fix
    local claude_response="/tmp/claude_response.json"
    if claude --output-format json --no-interaction < "$temp_prompt" > "$claude_response" 2>/dev/null; then
        # Parse JSON response
        local success=$(jq -r '.success // false' "$claude_response" 2>/dev/null)
        local fix_applied=$(jq -r '.fix_applied // "No fix description"' "$claude_response" 2>/dev/null)
        local modified_content=$(jq -r '.modified_content // ""' "$claude_response" 2>/dev/null)
        local explanation=$(jq -r '.explanation // "No explanation provided"' "$claude_response" 2>/dev/null)
        
        if [ "$success" = "true" ] && [ -n "$modified_content" ]; then
            # Backup original file
            cp "$full_path" "${full_path}.backup"
            
            # Apply the fix
            echo "$modified_content" > "$full_path"
            
            # Run comprehensive tests before and after
            local test_id="claude_fix_$(date +%s)_$$"
            
            # Test original file first
            info "üß™ Testing original file before applying fix..."
            local original_test_passed=false
            if ../helpers/test_runner.sh test-file "${full_path}.backup" "original_$test_id" > /dev/null 2>&1; then
                original_test_passed=true
                info "‚úÖ Original file tests passed"
            else
                warn "‚ö†Ô∏è  Original file has test failures (proceeding with fix)"
            fi
            
            # Test modified file
            info "üß™ Testing modified file after applying fix..."
            if ../helpers/test_runner.sh test-file "$full_path" "modified_$test_id"; then
                success "‚úÖ Fix applied and all tests passed: $fix_applied"
                info "Explanation: $explanation"
                
                # Additional regression test - compare test results
                if [ "$original_test_passed" = true ]; then
                    if run_regression_test "${full_path}.backup" "$full_path" "$test_id"; then
                        success "üéâ Regression tests passed - no functionality broken"
                    else
                        warn "‚ö†Ô∏è  Potential regression detected, but syntax is valid"
                    fi
                fi
                
                # Mark TODO as completed
                mark_todo_completed "$todo_item" "$fix_applied" "$explanation"
                
                # Log successful fix to memory
                local fix_duration=$(($(date +%s) - fix_start_time))
                ../helpers/memory_manager.sh log-fix "$todo_item" "$full_path" "$fix_applied" "$explanation" "success" "passed" "$fix_duration"
                
                # Clean up backup after successful fix
                rm -f "${full_path}.backup"
                return 0
            else
                # Revert changes if tests fail
                warn "üí• Tests failed after applying fix, reverting changes..."
                mv "${full_path}.backup" "$full_path"
                error "‚ùå Fix caused test failures, reverted to original version"
                
                # Log the failed attempt
                log_failed_fix "$todo_item" "$fix_applied" "$explanation" "Tests failed after applying fix"
                
                # Log reverted fix to memory
                local fix_duration=$(($(date +%s) - fix_start_time))
                ../helpers/memory_manager.sh log-fix "$todo_item" "$full_path" "$fix_applied" "$explanation" "reverted" "failed" "$fix_duration"
                
                return 1
            fi
        else
            warn "Claude could not generate a valid fix"
            
            # Log failed attempt to memory
            local fix_duration=$(($(date +%s) - fix_start_time))
            ../helpers/memory_manager.sh log-fix "$todo_item" "$full_path" "No fix generated" "Claude could not generate a valid fix" "failed" "not_attempted" "$fix_duration"
            
            return 1
        fi
    else
        error "Failed to get response from Claude CLI"
        
        # Log failed attempt to memory
        local fix_duration=$(($(date +%s) - fix_start_time))
        ../helpers/memory_manager.sh log-fix "$todo_item" "$full_path" "Communication error" "Failed to get response from Claude CLI" "failed" "not_attempted" "$fix_duration"
        
        return 1
    fi
    
    # Cleanup
    rm -f "$temp_prompt" "$claude_response"
}

# Verify file syntax
verify_file_syntax() {
    local file_path="$1"
    local file_ext="${file_path##*.}"
    
    case "$file_ext" in
        py)
            python3 -m py_compile "$file_path" 2>/dev/null
            ;;
        js|jsx)
            node -c "$file_path" 2>/dev/null
            ;;
        ts|tsx)
            if command -v tsc &> /dev/null; then
                tsc --noEmit "$file_path" 2>/dev/null
            else
                # Skip TypeScript checking if tsc not available
                return 0
            fi
            ;;
        *)
            # For other file types, assume syntax is OK
            return 0
            ;;
    esac
}

# Run regression test comparing before and after
run_regression_test() {
    local original_file="$1"
    local modified_file="$2"
    local test_id="$3"
    
    info "üîç Running regression analysis..."
    
    # Compare test results from before and after
    local original_results="../postbox/test_results/original_${test_id}.json"
    local modified_results="../postbox/test_results/modified_${test_id}.json"
    
    if [ -f "$original_results" ] && [ -f "$modified_results" ]; then
        # Compare number of passed tests
        local original_passed=$(jq '[.tests[] | select(.status == "passed")] | length' "$original_results" 2>/dev/null || echo "0")
        local modified_passed=$(jq '[.tests[] | select(.status == "passed")] | length' "$modified_results" 2>/dev/null || echo "0")
        
        # Compare number of failed tests
        local original_failed=$(jq '[.tests[] | select(.status == "failed")] | length' "$original_results" 2>/dev/null || echo "0")
        local modified_failed=$(jq '[.tests[] | select(.status == "failed")] | length' "$modified_results" 2>/dev/null || echo "0")
        
        info "Test comparison: Original($original_passed passed, $original_failed failed) vs Modified($modified_passed passed, $modified_failed failed)"
        
        # Regression if we have fewer passing tests or more failing tests
        if [ "$modified_passed" -lt "$original_passed" ] || [ "$modified_failed" -gt "$original_failed" ]; then
            warn "üî¥ Regression detected: Test results degraded"
            return 1
        else
            success "üü¢ No regression: Test results maintained or improved"
            return 0
        fi
    else
        warn "‚ö†Ô∏è  Could not compare test results (missing files)"
        return 0  # Don't fail if we can't compare
    fi
}

# Log failed fix attempts
log_failed_fix() {
    local todo_item="$1"
    local fix_attempted="$2"
    local explanation="$3"
    local failure_reason="$4"
    
    local failed_fixes_file="$POSTBOX_DIR/failed_fixes.md"
    
    # Initialize file if it doesn't exist
    if [ ! -f "$failed_fixes_file" ]; then
        cat > "$failed_fixes_file" << 'EOF'
# Failed Fix Attempts

This file tracks fixes that were attempted but failed testing.

EOF
    fi
    
    # Add failed attempt
    {
        echo "## Failed Fix: $(date '+%Y-%m-%d %H:%M:%S')"
        echo ""
        echo "**Original TODO:** $todo_item"
        echo ""
        echo "**Fix Attempted:** $fix_attempted"
        echo ""
        echo "**Explanation:** $explanation"
        echo ""
        echo "**Failure Reason:** $failure_reason"
        echo ""
        echo "**Status:** Auto-reverted to original version"
        echo ""
        echo "---"
        echo ""
    } >> "$failed_fixes_file"
    
    warn "üìù Failed fix logged to failed_fixes.md"
}

# Mark TODO item as completed
mark_todo_completed() {
    local todo_item="$1"
    local fix_applied="$2"
    local explanation="$3"
    
    # Remove the TODO item from todo.md
    if [ -f "$TODO_FILE" ]; then
        # Create temp file without the completed item
        grep -v "^$(echo "$todo_item" | sed 's/[][\.*^$()+?{|}/\&/g')" "$TODO_FILE" > "${TODO_FILE}.tmp"
        mv "${TODO_FILE}.tmp" "$TODO_FILE"
    fi
    
    # Add to completed-todos.md
    {
        echo "## Completed: $(date '+%Y-%m-%d %H:%M:%S')"
        echo ""
        echo "**Original TODO:** $todo_item"
        echo ""
        echo "**Fix Applied:** $fix_applied"
        echo ""
        echo "**Explanation:** $explanation"
        echo ""
        echo "---"
        echo ""
    } >> "$COMPLETED_FILE"
}

# Process pending TODO items
process_todos() {
    local todo_item=$(parse_todo_items)
    
    if [ -z "$todo_item" ]; then
        info "üìã No pending TODO items found"
        return 0
    fi
    
    info "üìã Found TODO item: $todo_item"
    
    # Apply fix for the first TODO item
    if apply_fix "$todo_item"; then
        success "‚úÖ Successfully completed TODO item"
    else
        error "‚ùå Failed to complete TODO item"
    fi
}

# Monitor for new TODO items
monitor_todos() {
    local last_check=$(date +%s)
    
    while true; do
        # Check if TODO file has been updated
        if [ -f "$TODO_FILE" ]; then
            local todo_mod_time=$(stat -c %Y "$TODO_FILE" 2>/dev/null || stat -f %m "$TODO_FILE" 2>/dev/null || echo 0)
            
            if [ "$todo_mod_time" -gt "$last_check" ]; then
                info "üìù TODO file updated, processing items..."
                process_todos
                last_check=$(date +%s)
            fi
        fi
        
        # Also check periodically
        local current_time=$(date +%s)
        local time_diff=$((current_time - last_check))
        
        if [ $time_diff -ge $SCAN_INTERVAL ]; then
            process_todos
            last_check=$current_time
        fi
        
        sleep 10  # Check every 10 seconds
    done
}

# Main execution
main() {
    info "üöÄ Starting Claude Code Fix Agent"
    
    # Pre-flight checks
    check_claude_cli
    check_directories
    create_lock
    
    # Initial processing
    process_todos
    
    # Start monitoring loop
    info "üìä Starting monitoring loop (checking every $SCAN_INTERVAL seconds)"
    monitor_todos
}

# Handle script termination
handle_signal() {
    info "Received termination signal, shutting down..."
    cleanup
    exit 0
}

trap handle_signal SIGINT SIGTERM

# Run main function
main "$@"